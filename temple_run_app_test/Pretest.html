{% block styles %}
<link rel="stylesheet" href="{% static 'global/global.css' %}">
{% endblock %}


{% block content %}

<div id="jspsych-target"></div>
<div id="debug-accuracy" style="
  position: fixed;
  top: 10px;
  right: 20px;
  background-color: rgba(255,255,255,0.9);
  padding: 8px 12px;
  border: 1px solid #aaa;
  border-radius: 5px;
  font-weight: bold;
  color: darkred;
  z-index: 9999;
">
    Debug Accuracy: (waiting...)
</div>

<div id="debug-feedback" style="
  position: fixed;
  top: 210px;
  right: 20px;
  background-color: rgba(255,255,255,0.9);
  padding: 8px 12px;
  border: 1px solid #aaa;
  border-radius: 5px;
  font-weight: bold;
  color: navy;
  z-index: 9999;
">
    Debug Feedback: (waiting...)
</div>

<div id="debug-pretest" style="
  position: fixed;
  top: 280px;
  right: 20px;
  background-color: rgba(255,255,255,0.9);
  padding: 8px 12px;
  border: 1px solid #aaa;
  border-radius: 5px;
  font-weight: bold;
  color: darkgreen;
  z-index: 9999;
">
    Debug Pretest: (waiting...)
</div>


<script src="https://unpkg.com/jspsych@7.3.0"></script>
<script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response"></script>
<script src="https://unpkg.com/@jspsych/plugin-preload"></script>
<script src="https://unpkg.com/@jspsych/plugin-call-function"></script>
<script src="{% static 'messages.js' %}"></script>

<script>

    const jsPsych = initJsPsych({
        display_element: 'jspsych-target'
    });
    localStorage.removeItem('autosave_data');

    const settings = JSON.parse('{{ test_settings|safe }}');

    const taskTimeInMinutes = 16;
    let stimulusTimeInMilliseconds = settings.stimulus_time_duration_pretest;
    const seriesData = JSON.parse('{{ series_data|safe }}');

    let digitAccuracy = 0;
    let letterAccuracy = 0;
    let overallAccuracy = 0;
    let correctDigits = 0;
    let correctHitLetters = 0;
    let correctRejectLetters = 0;
    let totalDigits = 0;
    let totalHitLetters = 0;
    let totalRejectLetters = 0;

    const accuracyThreshold = 0.85;

    let error = 0;
    let accumulatedError = 0;

    let currentPhase = null;
    let pretestHCL = null, pretestLCL = null;

    function resetStats() {
        digitAccuracy = 0;
        letterAccuracy = 0;
        overallAccuracy = 0;
        correctDigits = 0;
        correctHitLetters = 0;
        correctRejectLetters = 0;
        totalDigits = 0;
        totalHitLetters = 0;
        totalRejectLetters = 0;
    }

    function resetDebugInfo() {
        resetStats();
        updateDebugAccuracy();        // redraw the accuracy box -> 0 %
        updateDebugFeedback(null);
        updateDebugPretestInfo();
    }

    const resetTrial = {
        type: jsPsychCallFunction,
        func: () => {
            resetDebugInfo();
        }
    };

    function saveTrialToLocalStorage(trialData) {
        let allData = JSON.parse(localStorage.getItem('autosave_data')) || [];
        allData.push(trialData);
        localStorage.setItem('autosave_data', JSON.stringify(allData));
    }


    const stimulusHTML = content => `
    <div class="fullscreen-centered-content stimulus-display-div">
        ${content}
    </div>
`;
    const blankScreen = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: stimulusHTML(''),
        choices: "NO_KEYS",
        trial_duration: 100
    };

    function makeStimulus(content, choices, correctResponse, trialType) {
        return {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: stimulusHTML(content),
            choices: choices,
            response_ends_trial: false,
            trial_duration: () => stimulusTimeInMilliseconds,
            post_trial_gap: 100,
            on_finish: function (data) {
                data.correct = data.response === correctResponse;

                saveTrialToLocalStorage({
                    phase: currentPhase,
                    trial_type: trialType,
                    stimulus: content,
                    response: data.response,
                    correct_response: correctResponse,
                    correct: data.correct,
                    digit_accuracy: digitAccuracy,
                    letter_accuracy: letterAccuracy,
                    overall_accuracy: overallAccuracy,
                    rt: data.rt,
                    timestamp: Date.now()
                });
                updateDebugFeedback(data.correct);
                updateDebugPretestInfo();
                if (trialType === 'digit') {
                    recalculateDigitAccuracy(data.correct);
                } else if (trialType === 'letter') {
                    recalculateLetterAccuracy(data.correct, data.response === ' ');
                }
                updateDebugAccuracy();
            }
        };
    }

    function downloadCSVFromLocalStorage(filename = 'experiment_data.csv') {
        const data = JSON.parse(localStorage.getItem('autosave_data')) || [];

        if (data.length === 0) return;

        // Build CSV header section from settings
        const settingsHeader = ['--- Experiment Settings ---'];
        for (const [key, value] of Object.entries(settings)) {
            settingsHeader.push(`${key},${value}`);
        }

        // Leave a blank line before trial data
        settingsHeader.push('', '--- Trial Data ---');

        // Build data rows
        const keys = Object.keys(data[0]);
        const csvRows = [keys.join(",")];
        for (let row of data) {
            csvRows.push(keys.map(k => JSON.stringify(row[k] ?? '')).join(","));
        }

        const csvString = [...settingsHeader, ...csvRows].join("\n");
        const blob = new Blob([csvString], {type: "text/csv"});
        const url = URL.createObjectURL(blob);

        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }


    function recalculateDigitAccuracy(lastAnswerCorrect) {
        if (lastAnswerCorrect) {
            correctDigits++;
        }
        totalDigits++;
        digitAccuracy = correctDigits / totalDigits;
        overallAccuracy = 0.65 * letterAccuracy + 0.35 * digitAccuracy;
    }

    function recalculateLetterAccuracy(lastAnswerCorrect, hit) {
        if (hit) {
            totalHitLetters++;
            if (lastAnswerCorrect) {
                correctHitLetters++;
            }
        } else {
            totalRejectLetters++;
            if (lastAnswerCorrect) {
                correctRejectLetters++;
            }
        }

        const letterHitAccuracy = totalHitLetters > 0 ? correctHitLetters / totalHitLetters : 0;
        const letterRejectionAccuracy = totalRejectLetters > 0 ? correctRejectLetters / totalRejectLetters : 0;

        letterAccuracy = 0.65 * letterHitAccuracy + 0.35 * letterRejectionAccuracy;
        overallAccuracy = 0.65 * letterAccuracy + 0.35 * digitAccuracy;
    }

    const getRandomBlock = () => {
        return jsPsych.randomization.sampleWithoutReplacement(seriesData, 1)[0];
    };

    const generateDigitBlock = () => {
        const timeline = [];
        for (let i = 0; i < 10; i++) {
            pushRandomNumberStimulus(timeline);
            timeline.push(blankScreen);
        }
        return timeline;
    };

    const generateLetterBlock = () => {
        const timeline = [];
        const block = getRandomBlock();
        for (let i = 0; i < block.letters.length; i++) {
            const letter = block.letters[i];
            const expected = block.responses[i] === "1" ? " " : null;
            timeline.push(makeStimulus(letter, [' '], expected, 'letter'));
            timeline.push(blankScreen);
        }
        return timeline;
    };

    const generateLetterDigitBlock = () => {
        const timeline = [];
        const block = getRandomBlock();
        for (let i = 0; i < block.letters.length; i++) {
            // Letter
            const letter = block.letters[i];
            const letterExpected = block.responses[i] === "1" ? " " : null;
            timeline.push(makeStimulus(letter, [' '], letterExpected, 'letter'));
            pushRandomNumberStimulus(timeline);
        }
        return timeline;
    };

    // This object represents ONE ATTEMPT at the training. It is NOT a loop.
    const digit_training_block = {
        // We use a dynamic timeline function to generate fresh trials each time this block runs.
        timeline: () => {
            // generateDigitBlock() is your helper function that returns an array of trials.
            const trials = generateDigitBlock();

            // We tack the "repeat" message onto the end, but it will only show if the
            // conditional_function is true.
            const feedback_message = {
                timeline: [MESSAGES.repeatTraining, resetTrial],
                conditional_function: () => {
                    // This condition is checked AFTER the trials have run.
                    return digitAccuracy < accuracyThreshold;
                }
            };

            return [...trials, feedback_message];
        }
    };

    async function digitTrainingLoop() {
        while (digitAccuracy < accuracyThreshold) {
            resetDebugInfo();
            const toRun = generateDigitBlock();
            await jsPsych.run(toRun);
            if (digitAccuracy < accuracyThreshold) {
                await jsPsych.run([MESSAGES.repeatTraining]);
            }
        }
    };


    async function letterTrainingLoop() {
        while (letterAccuracy < accuracyThreshold) {
            resetDebugInfo();
            const toRun = generateLetterBlock();
            await jsPsych.run(toRun);
            if (letterAccuracy < accuracyThreshold) {
                await jsPsych.run([MESSAGES.repeatTraining]);
            }
        }
    };

    async function letterDigitTrainingLoop() {
        while (overallAccuracy < accuracyThreshold) {
            resetDebugInfo();
            const toRun = generateLetterDigitBlock();
            await jsPsych.run(toRun);
            if (overallAccuracy < accuracyThreshold) {
                await jsPsych.run([MESSAGES.repeatTraining]);
            }
        }
    };

    async function preTestLoop() {
        stimulusTimeInMilliseconds -= 100;
        updateDebugPretestInfo();
        while (error < 3 && accumulatedError < 5) {
            resetDebugInfo();
            const toRun = makeLetterDigitTimelineFromSeries();
            await jsPsych.run(toRun);
            if (overallAccuracy < accuracyThreshold) {
                error++;
                accumulatedError++;
            } else {
                error = 0; // Reset consecutive errors on success
                stimulusTimeInMilliseconds -= 100; // Get faster
            }
            if (error >= 3) {
                pretestHCL = stimulusTimeInMilliseconds + 100; // Revert to last successful speed
                pretestLCL = pretestHCL * 1.5;
                break;
            }
            if (accumulatedError >= 5) {
                pretestHCL = stimulusTimeInMilliseconds;
                pretestLCL = pretestHCL * 1.5;
                break;
            }
            await jsPsych.run([MESSAGES.pause]);
        }
    }

    const blockLength = getRandomBlock().letters.length;

    async function mainTaskLoop() {
        const stimulusTimeInSeconds = stimulusTimeInMilliseconds / 1000;
        const taskTimeInSeconds = taskTimeInMinutes * 60;
        const blockTimeInSeconds = blockLength * 2 * stimulusTimeInSeconds;
        const repetitions = Math.floor(taskTimeInSeconds / blockTimeInSeconds);
        for (i = 0; i < repetitions; i++) {
            resetDebugInfo();
            const toRun = makeLetterDigitTimelineFromSeries();
            await jsPsych.run(toRun);
            console.log("round: " + (i + 1) + "with speed: " + stimulusTimeInMilliseconds + "ms");
        }
    }

    function updateDebugAccuracy() {
        const debugBox = document.getElementById('debug-accuracy');
        if (debugBox) {
            debugBox.innerText =
                `Debug Accuracy:\nOverall: ${(overallAccuracy * 100).toFixed(2)}%\nLetters: ${(letterAccuracy * 100).toFixed(1)}%\nDigits: ${(digitAccuracy * 100).toFixed(1)}%`;
        }
    }


    function updateDebugFeedback(isCorrect) {
        const feedbackBox = document.getElementById('debug-feedback');
        if (isCorrect === null) {
            feedbackBox.innerText = 'Debug Feedback: (waiting…)';
            feedbackBox.style.color = 'navy';
        } else {
            feedbackBox.innerText = `Debug Feedback: ${isCorrect ? "✓ Correct" : "✗ Incorrect"}`;
            feedbackBox.style.color = isCorrect ? 'green' : 'red';
        }
    }

    function updateDebugPretestInfo() {
        const box = document.getElementById('debug-pretest');
        if (box) {
            box.innerText = `Debug Pretest:\nErrors: ${error}\nAccumulated Errors: ${accumulatedError}\nStimulus Duration Time: ${stimulusTimeInMilliseconds}ms`;
        }
    }


    function makeLetterDigitTimelineFromSeries() {
        const trials = [];
        const block = getRandomBlock();
        for (let i = 0; i < blockLength; i++) {
            const letter = block.letters[i];
            const expected = block.responses[i] === "1" ? " " : null;
            trials.push(makeStimulus(letter, [' '], expected, 'letter'));

            pushRandomNumberStimulus(trials);
        }
        return trials;
    }

    function pushRandomNumberStimulus(trials) {
        const number = jsPsych.randomization.sampleWithoutReplacement([1, 2, 3, 4, 6, 7, 8, 9], 1)[0];
        const correctKey = number % 2 === 0 ? '2' : '3';
        trials.push(makeStimulus(number, ['2', '3'], correctKey, 'digit'));
    }

    (async () => {
        await jsPsych.run([
            {
                type: jsPsychPreload,
                images: INSTRUCTIONS.instruction_images
            },
            MESSAGES.welcome,
            INSTRUCTIONS.generalInstructions,
            INSTRUCTIONS.digitsInstructions]);
        await digitTrainingLoop();
        await jsPsych.run(
            [
                resetTrial,
                MESSAGES.digitTrainingDone,
                INSTRUCTIONS.lettersInstructions]);
        await letterTrainingLoop();
        await jsPsych.run([
            resetTrial,
            MESSAGES.letterTrainingDone,
            INSTRUCTIONS.lettersDigitsInstructions,]);
        await letterDigitTrainingLoop();
        await jsPsych.run([
            resetTrial,
            MESSAGES.pretestInstructions]);
        await preTestLoop();
        await mainTaskLoop();
        jsPsych.run([MESSAGES.pretestFinished]);
        downloadCSVFromLocalStorage();
        jsPsych.data.reset();
        localStorage.removeItem('autosave_data');
    })();

</script>

{% endblock %}