{% block styles %}
<link rel="stylesheet" href="{% static 'global/global.css' %}">
{% endblock %}


{% block content %}

<div id="jspsych-target"></div>
<div id="debug-accuracy" style="
  position: fixed;
  top: 10px;
  right: 20px;
  background-color: rgba(255,255,255,0.9);
  padding: 8px 12px;
  border: 1px solid #aaa;
  border-radius: 5px;
  font-weight: bold;
  color: darkred;
  z-index: 9999;
">
    Debug Accuracy: (waiting...)
</div>

<div id="debug-feedback" style="
  position: fixed;
  top: 210px;
  right: 20px;
  background-color: rgba(255,255,255,0.9);
  padding: 8px 12px;
  border: 1px solid #aaa;
  border-radius: 5px;
  font-weight: bold;
  color: navy;
  z-index: 9999;
">
    Debug Feedback: (waiting...)
</div>

<div id="debug-pretest" style="
  position: fixed;
  top: 280px;
  right: 20px;
  background-color: rgba(255,255,255,0.9);
  padding: 8px 12px;
  border: 1px solid #aaa;
  border-radius: 5px;
  font-weight: bold;
  color: darkgreen;
  z-index: 9999;
">
    Debug Pretest: (waiting...)
</div>


<script src="https://unpkg.com/jspsych@7.3.0"></script>
<script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response"></script>
<script src="https://unpkg.com/@jspsych/plugin-preload"></script>
<script src="https://unpkg.com/@jspsych/plugin-call-function"></script>

<script>
    // --- Add this helper function at the top of your script ---

    /**
     * Creates a visually styled instruction screen that matches the experiment's look.
     * @param {string} innerHTML - The HTML content to place inside the bordered box.
     * @returns {string} - The full HTML for the jsPsych stimulus.
     */
    function createInstructionScreen(innerHTML) {
        return `
        <div class="fullscreen-centered-content instruction-box">
            ${innerHTML}
        </div>
    `;
    }

    const jsPsych = initJsPsych({
        display_element: 'jspsych-target'
    });
    localStorage.removeItem('autosave_data');

    const settings = JSON.parse('{{ test_settings|safe }}');

    let stimulusTime = settings.stimulus_time_duration_pretest;
    const seriesData = JSON.parse('{{ series_data|safe }}');

    let digitAccuracy = 0;
    let letterAccuracy = 0;
    let overallAccuracy = 0;
    let correctDigits = 0;
    let correctHitLetters = 0;
    let correctRejectLetters = 0;
    let totalDigits = 0;
    let totalHitLetters = 0;
    let totalRejectLetters = 0;

    const accuracyThreshold = 0.85;

    let error = 0;
    let accumulatedError = 0;

    let currentPhase = null;

    function resetStats() {
        digitAccuracy = 0;
        letterAccuracy = 0;
        overallAccuracy = 0;
        correctDigits = 0;
        correctHitLetters = 0;
        correctRejectLetters = 0;
        totalDigits = 0;
        totalHitLetters = 0;
        totalRejectLetters = 0;
    }

    function resetDebugInfo() {
        resetStats();
        updateDebugAccuracy();        // redraw the accuracy box -> 0 %
        updateDebugFeedback(null);
        updateDebugPretestInfo();
    }

    const resetTrial = {
        type: jsPsychCallFunction,
        func: () => {
            resetDebugInfo();
        }
    };

    const pauseRestartMessage = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: createInstructionScreen(`
        <p>PAUSE: Let's take a break,</p>`),
        choices: "ALL_KEYS",
        trial_duration: 2000, // Or wait for key press
    };

    const pretestFinishedMessage = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: createInstructionScreen(`
            <h1>CONGRATULATIONS!</h1>
            <p>THE PRETEST IS FINISHED</p>`),
        choices: "NO_KEYS",
        trial_duration: 6000,
    }

    function saveTrialToLocalStorage(trialData) {
        let allData = JSON.parse(localStorage.getItem('autosave_data')) || [];
        allData.push(trialData);
        localStorage.setItem('autosave_data', JSON.stringify(allData));
    }

    const instruction_images = [
        '/static/images/pretest/General_Instructions_REMADE.bmp',
        '/static/images/pretest/Digits_Instructions_REMADE.bmp',
        '/static/images/pretest/Letters_Instructions_REMADE.bmp',
        '/static/images/pretest/Letters_Digits_Instructions_REMADE.bmp'
    ];

    // show each instruction image, wait for 'y' key to continue
    const generalInstructions = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: `<img src="/static/images/pretest/General_Instructions_REMADE.bmp" style="max-width: 100%">`,
        choices: ['y']
    };

    const digitsInstructions = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: `<img src="/static/images/pretest/Digits_Instructions_REMADE.bmp" style="max-width: 100%">`,
        choices: ['y'],
        on_finish: function () {
            currentPhase = "digit training";
        }
    };

    const lettersInstructions = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: `<img src="/static/images/pretest/Letters_Instructions_REMADE.bmp" style="max-width: 100%">`,
        choices: ['y'],
        on_finish: function () {
            currentPhase = "letter training";
        }
    };

    const lettersDigitsInstructions = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: `<img src="/static/images/pretest/Letters_Digits_Instructions_REMADE.bmp" style="max-width: 100%">`,
        choices: ['y'],
        on_finish: function () {
            currentPhase = "pre-pre-test";
        }
    };

    const stimulusHTML = content => `
    <div class="fullscreen-centered-content stimulus-display-div">
        ${content}
    </div>
`;

    const blankScreen = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: stimulusHTML(''),
        choices: "NO_KEYS",
        trial_duration: 100
    };

    function makeStimulus(content, choices, correctResponse, trialType) {
        return {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: stimulusHTML(content),
            choices: choices,
            response_ends_trial: false,
            trial_duration: stimulusTime,
            post_trial_gap: 100,
            on_finish: function (data) {
                data.correct = data.response === correctResponse;

                saveTrialToLocalStorage({
                    phase: currentPhase,
                    trial_type: trialType,
                    stimulus: content,
                    response: data.response,
                    correct_response: correctResponse,
                    correct: data.correct,
                    digit_accuracy: digitAccuracy,
                    letter_accuracy: letterAccuracy,
                    overall_accuracy: overallAccuracy,
                    rt: data.rt,
                    timestamp: Date.now()
                });
                updateDebugFeedback(data.correct);
                updateDebugPretestInfo();
                if (trialType === 'digit') {
                    recalculateDigitAccuracy(data.correct);
                } else if (trialType === 'letter') {
                    recalculateLetterAccuracy(data.correct, data.response === ' ');
                }
                updateDebugAccuracy();
            }
        };
    }

    function downloadCSVFromLocalStorage(filename = 'experiment_data.csv') {
        const data = JSON.parse(localStorage.getItem('autosave_data')) || [];

        if (data.length === 0) return;

        // Build CSV header section from settings
        const settingsHeader = ['--- Experiment Settings ---'];
        for (const [key, value] of Object.entries(settings)) {
            settingsHeader.push(`${key},${value}`);
        }

        // Leave a blank line before trial data
        settingsHeader.push('', '--- Trial Data ---');

        // Build data rows
        const keys = Object.keys(data[0]);
        const csvRows = [keys.join(",")];
        for (let row of data) {
            csvRows.push(keys.map(k => JSON.stringify(row[k] ?? '')).join(","));
        }

        const csvString = [...settingsHeader, ...csvRows].join("\n");
        const blob = new Blob([csvString], {type: "text/csv"});
        const url = URL.createObjectURL(blob);

        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }


    function recalculateDigitAccuracy(lastAnswerCorrect) {
        if (lastAnswerCorrect) {
            correctDigits++;
        }
        totalDigits++;
        digitAccuracy = correctDigits / totalDigits;
        overallAccuracy = 0.65 * letterAccuracy + 0.35 * digitAccuracy;
    }

    function recalculateLetterAccuracy(lastAnswerCorrect, hit) {
        if (hit) {
            totalHitLetters++;
            if (lastAnswerCorrect) {
                correctHitLetters++;
            }
        } else {
            totalRejectLetters++;
            if (lastAnswerCorrect) {
                correctRejectLetters++;
            }
        }

        const letterHitAccuracy = totalHitLetters > 0 ? correctHitLetters / totalHitLetters : 0;
        const letterRejectionAccuracy = totalRejectLetters > 0 ? correctRejectLetters / totalRejectLetters : 0;

        letterAccuracy = 0.65 * letterHitAccuracy + 0.35 * letterRejectionAccuracy;
        overallAccuracy = 0.65 * letterAccuracy + 0.35 * digitAccuracy;
    }

    const repeatTrainingMessage = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: createInstructionScreen(`<h1>LET'S REPEAT IT!</h1><div class="key-prompt">Press any key to continue.</div>`),
        choices: "ALL_KEYS",
    };


    const generateNewDigitBlock = () => {
        const timeline = [];
        for (let i = 0; i < 10; i++) {
            pushRandomNumberStimulus(timeline);
            timeline.push(blankScreen);
        }
        return timeline;
    };

        // Generates a fresh block of letter trials from a random series
    const generateNewLetterBlock = () => {
        const timeline = [];
        const block = getRandomBlock();
        for (let i = 0; i < block.letters.length; i++) {
            const letter = block.letters[i];
            const expected = block.responses[i] === "1" ? " " : null;
            timeline.push(makeStimulus(letter, [' '], expected, 'letter'));
            timeline.push(blankScreen);
        }
        return timeline;
    };

    // Generates a fresh block of combined letter/digit trials
    const generateNewCombinedBlock = () => {
        const timeline = [];
        const block = getRandomBlock();
        for (let i = 0; i < block.letters.length; i++) {
            // Letter
            const letter = block.letters[i];
            const letterExpected = block.responses[i] === "1" ? " " : null;
            timeline.push(makeStimulus(letter, [' '], letterExpected, 'letter'));
            pushRandomNumberStimulus(trials);
        }
        return timeline;
    };

    const digitTrainingLoop = {
        timeline: [
            resetTrial,
            {timeline: generateNewDigitBlock},
            {
                timeline: [repeatTrainingMessage],
                conditional_function: () => digitAccuracy < accuracyThreshold
            }
        ],
        loop_function: () => digitAccuracy < accuracyThreshold
    };

    const digitTrainingDone = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: createInstructionScreen(`
            <h1>WELL DONE!</h1>
            <p>Next, we'll move on with some letters.</p>
            <div class="key-prompt">Press any key to see the new instructions.</div>`),
        choices: "ALL_KEYS",
    };


    const letterTrainingLoop = {
        timeline: [
            resetTrial,
            { timeline: generateNewLetterBlock },
            {
                timeline: [repeatTrainingMessage],
                conditional_function: () => letterAccuracy < accuracyThreshold
            }
        ],
        loop_function: () => letterAccuracy < accuracyThreshold
    };


    const letterTrainingDone = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: createInstructionScreen(`
            <h1>WELL DONE!</h1>
            <p>Now, let's do some letters and digits at the same time.</p>
            <div class="key-prompt">Press any key to see the new instructions.</div>`),
        choices: "ALL_KEYS",
    };

    const getRandomBlock = () => {
        return jsPsych.randomization.sampleWithoutReplacement(seriesData, 1)[0];
    };

    function updateDebugAccuracy() {
        const debugBox = document.getElementById('debug-accuracy');
        if (debugBox) {
            debugBox.innerText =
                `Debug Accuracy:\nOverall: ${(overallAccuracy * 100).toFixed(2)}%\nLetters: ${(letterAccuracy * 100).toFixed(1)}%\nDigits: ${(digitAccuracy * 100).toFixed(1)}%`;
        }
    }


    function updateDebugFeedback(isCorrect) {
        const feedbackBox = document.getElementById('debug-feedback');
        if (isCorrect === null) {
            feedbackBox.innerText = 'Debug Feedback: (waiting…)';
            feedbackBox.style.color = 'navy';
        } else {
            feedbackBox.innerText = `Debug Feedback: ${isCorrect ? "✓ Correct" : "✗ Incorrect"}`;
            feedbackBox.style.color = isCorrect ? 'green' : 'red';
        }
    }

    function updateDebugPretestInfo() {
        const box = document.getElementById('debug-pretest');
        if (box) {
            box.innerText = `Debug Pretest:\nErrors: ${error}\nAccumulated Errors: ${accumulatedError}\nStimulus Duration Time: ${stimulusTime}ms`;
        }
    }


    function makeLetterDigitTimelineFromSeries() {
        const trials = [];
        const block = getRandomBlock();
        for (let i = 0; i < block.letters.length; i++) {
            const letter = block.letters[i];
            const expected = block.responses[i] === "1" ? " " : null;
            trials.push(makeStimulus(letter, [' '], expected, 'letter'));

            pushRandomNumberStimulus(trials);
        }
        return trials;
    }

    function pushRandomNumberStimulus(trials) {
        const number = jsPsych.randomization.sampleWithoutReplacement([1, 2, 3, 4, 6, 7, 8, 9], 1)[0];
        const correctKey = number % 2 === 0 ? '2' : '3';
        trials.push(makeStimulus(number, ['2', '3'], correctKey, 'digit'));
    }

    (async () => {
        await jsPsych.run([
            {
                type: jsPsychPreload,
                images: instruction_images
            },
            {
                type: jsPsychHtmlKeyboardResponse,
                stimulus: createInstructionScreen(`
            <h1>WELCOME</h1>
            <div class="key-prompt">Please press any key to see the task instructions.</div>`),
                choices: "ALL_KEYS",
            },
            generalInstructions,
            digitsInstructions,
            digitTrainingLoop,
            digitTrainingDone,
            resetTrial,
            lettersInstructions,
            letterTrainingLoop,
            letterTrainingDone,
            resetTrial,
            lettersDigitsInstructions
        ]);

        while (overallAccuracy <= accuracyThreshold) {
            const trainingTrials = makeLetterDigitTimelineFromSeries();

            await jsPsych.run(trainingTrials);

            if (overallAccuracy <= accuracyThreshold) {
                await jsPsych.run(
                    pauseRestartMessage
                );

                jsPsych.data.reset();
                resetDebugInfo();
            }
        }

        resetDebugInfo();

        const pretest_instructions = [
            {
                type: jsPsychHtmlKeyboardResponse,
                stimulus: createInstructionScreen(`
            <h1>CONGRATULATIONS!</h1>
            <p">You are ready to start the Pretest.</p>`),
                choices: "NO_KEYS",
                trial_duration: 3000,
            },
            {
                type: jsPsychHtmlKeyboardResponse,
                stimulus: createInstructionScreen(`
                        <h1>Take a long break first.</h1>
                        <div class="key-prompt">Press any key when you feel rested and ready to continue.</div>`),
                choices: "ALL_KEYS",
            },
            {
                type: jsPsychHtmlKeyboardResponse,
                stimulus: createInstructionScreen(`
                        <h1>PRETEST</h1>
                        <div class="key-prompt">Press the space bar twice to start.</div>`),
                choices: [' '],
                post_trial_gap: 500
            },
            {
                type: jsPsychHtmlKeyboardResponse,
                stimulus: createInstructionScreen(`
                        <h1>PRETEST</h1>
                        <div class="key-prompt">Press the space bar twice to start.</div>`),
                choices: [' '],
                post_trial_gap: 500,
                on_finish: () => {
                    document.body.style.backgroundColor = '';
                }
            }
        ];

        await jsPsych.run(pretest_instructions);

        // actual pretest starts here
        let pretestHCL = null;
        let pretestLCL = null;

        // decreasing since they could handle 1500
        stimulusTime -= 100;
        currentPhase = "pre-test";
        while (overallAccuracy >= 0.01) {
            resetDebugInfo();
            const trials = makeLetterDigitTimelineFromSeries();

            await jsPsych.run(trials);

            if (overallAccuracy < 0.85) {
                error++;
                accumulatedError++;


                // Although this value is fixed to 3 in Borragan & Slama,2017, increasing it at 5 might increase the pretest calibration
                // the subject has had their performance across all tests dip below 85% 3 times. This ends the test. STD is keptat the current value.
                if (error >= 3) {
                    pretestHCL = stimulusTime + 100;
                    pretestLCL = 1.5 * pretestHCL;
                    await jsPsych.run(pretestFinishedMessage);
                    break;
                }
                if (accumulatedError >= 5) {
                    pretestHCL = stimulusTime;
                    pretestLCL = 1.5 * pretestHCL;
                    await jsPsych.run(pretestFinishedMessage);
                    break;
                }

                await jsPsych.run(pauseRestartMessage);
            } else {
                stimulusTime -= 100;
                error = 0;

                await jsPsych.run(pauseRestartMessage);
            }
        }


        downloadCSVFromLocalStorage();
        jsPsych.data.reset();
        localStorage.removeItem('autosave_data');

    })();

</script>

{% endblock %}
